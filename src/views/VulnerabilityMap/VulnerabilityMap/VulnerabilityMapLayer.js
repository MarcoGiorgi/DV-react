import { find } from 'lodash-es';
import React, { Component } from 'react';
import { connect } from 'react-redux';
import { GeoJSON } from 'react-leaflet';
import Control from 'react-leaflet-control';
import ACTIONS from '../../../modules/action';
import { RANGEMAPS } from './vulnerabilityranges';

class VulnerabilityMapLayer extends Component {
  constructor(props) {
    super(props);
    this.geoJsonRef = React.createRef();
    this.mapRef = this.props.mapRef;
  }

  componentDidMount() {
    this.loadGeoJSonData();
  }

  componentDidUpdate() {
    if (this.props.vulnerability.geoJson && !this.alreadyZoomed) {
      this.zoomToCountry();
      this.alreadyZoomed = true;
    }
    if (this.props.indicator !== this.currentIndicator) {
      this.currentIndicator = this.props.indicator;
      this.props.fetchVulnerabilityData(this.props.indicator);
    }
  }

  zoomToCountry() {
    const geoJson = this.geoJsonRef.current;

    if (geoJson) {
      const latlngbounds = geoJson.leafletElement.getBounds(); //  new L.latLngBounds(self.layers.admin1.getBounds());
      this.mapRef.current.leafletElement.fitBounds(latlngbounds);
    }
  }

  loadGeoJSonData() {
    if (this.props.vulnerability.admin1) {
      this.props.changeAdminLevel('admin1');
    } else if (this.props.vulnerability.admin2) {
      this.props.changeAdminLevel('admin2');
    } else if (this.props.vulnerability.admin3) {
      this.props.changeAdminLevel('admin3');
    }
  }

  getCurrentAdminLevel() {
    if (this.props.vulnerability.admin1) {
      return 'admin1';
    }
    if (this.props.vulnerability.admin2) {
      return 'admin2';
    }
    if (this.props.vulnerability.admin3) {
      return 'admin3';
    }
  }

  getRegionData(regionId, data) {
    return find(data, (item) => item.ubigeo === regionId);
  }

  getRegionColor(regionId, data) {
    const RANGE_MAPS = RANGEMAPS(this.props.language);

    const regionData = this.getRegionData(regionId, data);
    const adminLevel = this.getCurrentAdminLevel();

    if (regionData) {
      return RANGE_MAPS.findRange(
        adminLevel,
        this.props.vulnerability.indicator,
        regionData[this.props.vulnerability.indicator]
      ).color;
    }

    return '#AAAAAA';
  }

  render() {
    const self = this;
    const RANGE_MAPS = RANGEMAPS(this.props.language);

    const style = (feature) => {
      if (self.props.vulnerability.indicator) {
        const regionId = self.props.vulnerability.admin1
          ? feature.properties.IDDPTO
          : self.props.vulnerability.admin2
          ? feature.properties.IDPROV
          : self.props.vulnerability.admin3
          ? feature.properties.IDDIST
          : null;
        return {
          color: 'rgb(124, 181, 236)',
          fillColor: self.getRegionColor(regionId, this.props.vulnerability.data.current),
          stroke: 'rgb(red)',
          opacity: this.props.vulnerability.admin3 ? 0.3 : 1,
          weight: this.props.vulnerability.admin3 ? 1 : 1,
          fillOpacity: 1
        };
      }
      return {
        color: 'rgb(124, 181, 236)',
        fillColor: 'rgb(124, 181, 236)',
        stroke: 'rgb(red)',
        weight: 1
      };
    };

    const legend = () => {
      const legendItems = (ranges) => {
        const items = [];
        for (let i = 0; i < ranges.length; i++) {
          const range = ranges[i];
          items.push([<i style={{ background: range.color }} />, <span>{range.label()}</span>, <br />]);
        }

        return items;
      };

      if (this.props.vulnerability.indicator) {
        const ranges = RANGE_MAPS[this.getCurrentAdminLevel()][this.props.vulnerability.indicator];

        return (
          <Control position="bottomleft">
            <div className="legend">
              <h4>Leyenda</h4>
              {legendItems(ranges)}
            </div>
          </Control>
        );
      }
    };

    return (
      <>
        <GeoJSON
          ref={this.geoJsonRef}
          key={new Date().getTime()}
          data={this.props.vulnerability.geoJson}
          style={style}
          onEachFeature={(feature, layer) => {
            // self.props.indicatorLoading && self.props.vulnerability.indicator && self.props.indicatorLoading(self.props.vulnerability.indicator, true);
            // create name
            let name = feature.properties.NOMBDEP
              + (feature.properties.NOMBDIST ? ` - ${feature.properties.NOMBDIST}` : '')
              + (feature.properties.NOMBPROV ? ` - ${feature.properties.NOMBPROV}` : '');

            if (self.props.vulnerability.indicator) {
              const regionId = self.props.vulnerability.admin1
                ? feature.properties.IDDPTO
                : self.props.vulnerability.admin2
                ? feature.properties.IDPROV
                : self.props.vulnerability.admin3
                ? feature.properties.IDDIST
                : null;

              const regionData = self.getRegionData(regionId, self.props.vulnerability.data.current);

              if (regionData) {
                name = `${name} (${regionData[self.props.vulnerability.indicator]})`;
              }
            }

            layer.bindTooltip(name);
            layer.on('mouseover', () => {
              layer.openPopup();
            });
            layer.on('mouseout', () => {
              layer.closePopup();
            });
          }}
        />
        {legend()}
      </>
    );
  }
}

const mapStateToProps = (state) => ({
  language: state.language,
  vulnerability: state.vulnerability
});

const mapDispatchToProps = (dispatch) => ({
  changeAdminLevel: (newLevel) => dispatch(ACTIONS.VULNERABILITY.changeAdminLevel(newLevel)),
  fetchVulnerabilityData: (indicator) => dispatch(ACTIONS.VULNERABILITY.fetchVulnerabilityData(indicator))
});

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(VulnerabilityMapLayer);
